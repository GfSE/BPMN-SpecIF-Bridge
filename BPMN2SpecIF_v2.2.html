<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<script language="javascript" src="jszip/dist/jszip.js"></script>  
<script language="javascript" src="filesaver/src/FileSaver.js"></script>  
<script>
// Import http://stuk.github.io/jszip/ for zip files
// Import https://github.com/eligrey/FileSaver.js for downloading files

var svgFile;
var specifObject = new Object();
var fileDate = new Date();

// Einlesen der XML Datei
function readFile() {
	svgFile = document.getElementById("SVG").files[0];
	fileDate = fileDate.toISOString();
	console.log(fileDate);
	var xmlFile = document.getElementById("XML").files[0];
	var fileName = xmlFile.name;
	var reader = new FileReader();	
	reader.readAsText(xmlFile);
	reader.onloadend = function(){
//		console.log(reader.result);
		var xmlString = reader.result;
		document.getElementById("output").innerHTML = reader.result;
		analyzeFile(fileName, xmlString);
	}

	
}

// Durchlaufen der XML Datei und überführen in das SpecIF Format
function analyzeFile(fileName, xmlString) {
	var parser = new DOMParser();
	var xmlDoc = parser.parseFromString(xmlString,"text/xml");
	var typ,id,name,source,target,stereotype;
	var elements = new Array();
	var i, x;
	
	x = xmlDoc.getElementsByTagName("bpmn:collaboration");
	console.log(x);
	typ = x[0].nodeName;
	id = x[0].getAttribute("id");
	name = fileName.split(".")[0];
	elements.push(resourceFinder(typ,id,name,source,target));

	console.log(x[0].childNodes[1]); 
	typ = x[0].childNodes[1].nodeName;
	id = x[0].childNodes[1].getAttribute("processRef");
	name = x[0].childNodes[1].getAttribute("name");
	elements.push(resourceFinder(typ,id,name,source,target));
	
	console.log("START PROZESSAUSWERTUNG")
	x = xmlDoc.getElementsByTagName("bpmn:process")[0].childNodes;
	console.log(x);
	for (i = 0; i < x.length; i++){ // Schleife zum Erstellen aller Ressourcen und Platzhaltern für Gateways des Prozesses
		if (x[i].nodeName != "#text" && x[i].nodeName != "bpmn:sequenceFlow"){
			typ = x[i].nodeName;
			id = x[i].getAttribute("id");
			name = x[i].getAttribute("name");
			source = x[i].getAttribute("sourceRef");
			target = x[i].getAttribute("targetRef");
			elements.push(resourceFinder(typ,id,name,source,target,stereotype));
		}
	}
	console.log("RESSOURCEN SIND DRIN");
	console.log(elements);
	console.log("STATEMENT ERSTELLEN");

	for (i = 0; i < x.length; i++){ // Schleife zum erstellen der Statements zwischen den Ressourcen und Platzhaltern für Gateways
		if (x[i].nodeName == "bpmn:sequenceFlow"){
			typ = x[i].nodeName;
			id = x[i].getAttribute("id");
			name = x[i].getAttribute("name");
			source = x[i].getAttribute("sourceRef");
			target = x[i].getAttribute("targetRef");
			elements.push(statementFinder(elements,typ,id,name,source,target));
		}
	}
	
	console.log("STATEMENTS SIND DRIN");
	console.log(elements);
	
	console.log("GATEWAYS UND IHRE SEQUENFLUESSE AUFLOESEN");
	resolveGateways(elements);
	console.log("ELEMENTE BEREINIGT");
	
	id = 1;
	for (i = 1; i < elements.length; i++){ // Beziehungen zwischen Diagram und Elementen
		if (elements[i].resourceType == "RT-Act" || elements[i].resourceType == "RT-Evt" || elements[i].resourceType == "RT-Sta"){
			elements.push({id:"Diagram_shows_"+id, title:"SpecIF:shows", statementType:"ST-Visibility", subject:elements[0].id, object:elements[i].id, changedAt:fileDate});
			id++;
		}
	}

	id = 1;
	for (i = 2; i < elements.length; i++){ // Beziehungen zwischen Diagram und Elementen
		if (elements[i].resourceType == "RT-Act" || elements[i].resourceType == "RT-Evt" || elements[i].resourceType == "RT-Sta"){
			elements.push({id:"Diagram_contains_"+id, title:"SpecIF:contains", statementType:"ST-Containment", subject:elements[1].id, object:elements[i].id, changedAt:fileDate});
			id++;
		}
	}

	jsonBuilder(elements);
	
//	var myJSON = JSON.stringify(elements);
//	console.log(elements);
//	console.log(myJSON);
}

// Übersetzen eines BPMN-Elements in SpecIF
function resourceFinder(typ,id,name,source,target,stereotype) {
	if (typeof stereotype == "undefined"){
		stereotype = "none";
	}
	switch (typ){
		case "bpmn:collaboration":
			var properties = new Array();
			properties.push({ title:"dcterms:title", propertyType:"PT-Pln-Name", value:name},
							{title:"SpecIF:Diagram", propertyType:"PT-Pln-Diagram", value:"<div><p> Dies ist der hochgeladene BPMN-Prozess </p><p class=\"inline-label\"> Model View: </p><div class=\"forImage\" style=\"max-width: 600px;\" > <object data=\"BusinessProcess.svg\" type=\"image/svg+xml\" >BusinessProcess</object></div></div>"},
							{title:"SpecIF:Notation", propertyType:"PT-Pln-Notation", value:"BPMN 2.0 Process Diagram"});
			return erg = {id:id, title:name, properties:properties, resourceType:"RT-Pln", changedAt:fileDate};
			
		case "bpmn:startEvent":
		case "bpmn:endEvent":
			var properties = new Array();
			properties.push({ title:"dcterms:title", propertyType:"PT-Evt-Name", value:name},
							{ title:"SpecIF:Stereotype", propertyType:"PT-Evt-Stereotype", value:stereotype});
			return erg = {id:id, title:name, properties:properties, resourceType:"RT-Evt", changedAt:fileDate};
		
		case "bpmn:participant":		
		case "bpmn:task":
		case "bpmn:userTask":
			var properties = new Array();
			properties.push({ title:"dcterms:title", propertyType:"PT-Act-Name", value:name},
							{ title:"SpecIF:Stereotype", propertyType:"PT-Act-Stereotype", value:stereotype});
			return erg = {id:id, title:name, properties:properties, resourceType:"RT-Act", changedAt:fileDate};
			
		case "bpmn:parallelGateway":
			var incoming = new Array();
			var outgoing = new Array();
			return erg = {id:id, title:name, incoming:incoming, outgoing:outgoing, resourceType:"parallelGateway", changedAt:fileDate};			

		case "bpmn:exclusiveGateway":
			var incoming = new Array();
			var outgoing = new Array();
			return erg = {id:id, title:name, incoming:incoming, outgoing:outgoing, resourceType:"exklusiveGateway", changedAt:fileDate};			
		
		default:
			return "unknown element";
	}
}

function statementFinder(elements,typ,id,name,source,target) {
	switch (typ){
		case "bpmn:sequenceFlow":
			var subject = elements.find(function(resource) {
			return resource.id == source;});
//			console.log(subject);
			var object = elements.find(function(resource) {
			return resource.id == target;});
//			console.log(object);
			
			if (subject.resourceType == "RT-Act" && object.resourceType == "RT-Act"){
				return erg = {id:id, title:"SpecIF:follows", statementType:"ST-Following", subject:object.id, object:subject.id, changedAt:fileDate};
			}
			if ((subject.resourceType == "RT-Act" || subject.resourceType == "RT-Evt") && object.resourceType == "RT-Evt"){
				return erg = {id:id, title:"SpecIF:signals", statementType:"ST-Signalling", subject:subject.id, object:object.id, changedAt:fileDate};
			}
			if (subject.resourceType == "RT-Evt" && object.resourceType == "RT-Act"){
				return erg = {id:id, title:"SpecIF:triggers", statementType:"ST-Triggering", subject:subject.id, object:object.id, changedAt:fileDate};
			}
			if (subject.resourceType == "parallelGateway" || subject.resourceType == "exklusiveGateway"){
				subject.outgoing.push({id:id, title:name, statementType:"gatewayFlow", subject:subject.id, object:object.id, changedAt:fileDate});
			}
			if (object.resourceType == "parallelGateway" || object.resourceType == "exklusiveGateway"){
				object.incoming.push({id:id, title:name, statementType:"gatewayFlow", subject:subject.id, object:object.id, changedAt:fileDate});
			}
			
			return erg = {id:id, title:name, statementType:"gatewayFlow", subject:subject.id, object:object.id, changedAt:fileDate};
			
		default:
			return "unbekanntes Element";
	}
}

function resolveGateways(elements) {

	for (i = 0; i < elements.length; i++){ // Ressourcen und Statements aus den Gateways und ihren Sequenzflüssen bauen 
		if (elements[i].resourceType == "parallelGateway" && elements[i].incoming.length == 1){
//		console.log("case 1"); // Paralleles Gateway ausgehend 1 -> x
			for (j = 0; j < elements[i].outgoing.length; j++){ 
				elements[i].outgoing[j].subject = elements[i].incoming[0].subject;
				elements.push(statementFinder(elements, "bpmn:sequenceFlow", elements[i].outgoing[j].id, "", elements[i].outgoing[j].subject, elements[i].outgoing[j].object));
				}
		}
		
		if (elements[i].resourceType == "parallelGateway" && elements[i].outgoing.length == 1){
//		console.log("case 2"); // Paralleles Gateway eingehend x -> 1
		elements.push(resourceFinder("bpmn:task",elements[i].id,"Warte auf vorherige Elemente", null, null, elements[i].id));
		elements[i].id = null;
		elements.push(statementFinder(elements, "bpmn:sequenceFlow", elements[i].outgoing[0].id, "", elements[i].outgoing[0].subject, elements[i].outgoing[0].object));
			for (j = 0; j < elements[i].incoming.length; j++){ 
				elements.push(statementFinder(elements, "bpmn:sequenceFlow", elements[i].incoming[j].id, "", elements[i].incoming[j].subject, elements[i].incoming[j].object));
				}	
		}
		
		if (elements[i].resourceType == "exklusiveGateway" && elements[i].incoming.length == 1){
//		console.log("case 3"); // Exklusives Gateway ausgehend 1 -> x
			for (j = 0; j < elements[i].outgoing.length; j++){ 				
				elements.push(resourceFinder("bpmn:startEvent",elements[i].id+"_"+j, elements[i].outgoing[j].title, null, null, elements[i].id )); // eigentlich intermediate Event		
				elements.push(statementFinder(elements, "bpmn:sequenceFlow", elements[i].incoming[0].id+"_"+j, ""	, elements[i].incoming[0].subject	, elements[i].id+"_"+j));
				elements.push(statementFinder(elements, "bpmn:sequenceFlow", elements[i].outgoing[j].id, ""			, elements[i].id+"_"+j				, elements[i].outgoing[j].object)); // Bug bei Event auf Event
				}	
		}
		
		if (elements[i].resourceType == "exklusiveGateway" && elements[i].outgoing.length == 1){
//		console.log("case 4"); // Exklusives Gateway eingehend x -> 1
		// Objects anpassen
		}
	} // Ende der Schleife
	
	i = 0
	while (i != elements.length){ // alte Gateways und Sequenzflüsse löschen
		if (elements[i].statementType == "gatewayFlow" || elements[i].resourceType == "parallelGateway" || elements[i].resourceType == "exklusiveGateway"){
			elements.splice(i, 1);
		}
		else {
			i++
		}
	}
}

// Bauen eines JSON Objekts 
function jsonBuilder(elements) {
	console.log("JSON BAUEN");
	var d = new Date();
	var array = new Object();
	array.id = "BPMN-"+(d.getDate()+""+d.getMonth()+""+d.getFullYear()+""+d.getHours()+""+d.getMinutes()+""+d.getSeconds());
	array.title = prompt("Bitte geben Sie einen Projektnamen ein","DefaultTitle");
	array.description = prompt("Bitte geben Sie eine Projektbeschreibung ein","DefaultDescription");
	array.specifVersion = "0.10.3";
	
	var dataTypes = new Array(); // Benötigte Datentypen werden definiert
	dataTypes.push({ id:"DT-Integer", title:"Integer", type:"xs:integer", min:-32768, max:32767, changedAt:fileDate});
	dataTypes.push({ id:"DT-ShortString", title:"String[96]", description:"String with length 96", type:"xs:string", maxLength:96, changedAt:fileDate});
	dataTypes.push({ id:"DT-String", title:"String[1024]", description:"String with length 1024", type:"xs:string", maxLength:1024, changedAt:fileDate});
	dataTypes.push({ id:"DT-formattedText", title:"xhtml[1024]", description:"Formatted String with length 1024", type:"xhtml", maxLength:1024, changedAt:fileDate});
	
	var resourceTypes = new Array(); // Benötigte Ressourcentypen werden definiert
	resourceTypes.push({ 
		id:"RT-Pln", 
		title:"SpecIF:Diagram", 
		description:"A 'Diagram' is a graphical model view with a specific communication purpose, e.g. a business process or system composition.",
		propertyTypes:[{id:"PT-Pln-Name", title:"dcterms:title", dataType:"DT-ShortString", changedAt:fileDate},
						{id:"PT-Pln-Diagram", title:"SpecIF:Diagram", dataType:"DT-formattedText", changedAt:fileDate},
						{id:"PT-Pln-Notation", title:"SpecIF:Notation", dataType:"DT-ShortString", changedAt:fileDate}], icon:"&#9635;", changedAt:fileDate
	});
	resourceTypes.push({ id:"RT-Act", title:"FMC:Actor",
	description:"An 'Actor' is a fundamental model element type representing an active entity, be it an activity, a process step, a function, a system component or a role.",
	propertyTypes:[{id:"PT-Act-Name", title:"dcterms:title", dataType:"DT-ShortString", changedAt:fileDate},
					{id:"PT-Act-Stereotype", title:"SpecIF:Stereotype", dataType:"DT-ShortString", changedAt:fileDate}], icon:"&#9632;", changedAt:fileDate})
	resourceTypes.push({ id:"RT-Sta", title:"FMC:State",
	description:"A 'State' is a fundamental model element type representing a passive entity, be it a value, a condition, an information storage or even a physical shape.",
	propertyTypes:[{id:"PT-Sta-Name", title:"dcterms:title", dataType:"DT-ShortString", changedAt:fileDate},
					{id:"PT-Sta-Stereotype", title:"SpecIF:Stereotype", dataType:"DT-ShortString", changedAt:fileDate}], icon:"&#9679;", changedAt:fileDate})
	resourceTypes.push({ id:"RT-Evt", title:"FMC:Event",
	description:"An 'Event' is a fundamental model element type representing a time reference, a change in condition/value or more generally a synchronisation primitive.",
	propertyTypes:[{id:"PT-Evt-Name", title:"dcterms:title", dataType:"DT-ShortString", changedAt:fileDate},
					{id:"PT-Evt-Stereotype", title:"SpecIF:Stereotype", dataType:"DT-ShortString", changedAt:fileDate}], icon:"&#9830;", changedAt:fileDate})
	// neue Resourcen
	resourceTypes.push({ id:"RT-Not", title:"SpecIF:Note",
	description:"A 'Note' is additional information by the author referring to any resource.",
	propertyTypes:[{id:"PT-Not-Name", title:"dcterms:title", dataType:"DT-ShortString", changedAt:fileDate}], changedAt:fileDate})
	resourceTypes.push({ id:"RT-Col", title:"SpecIF:Collection",
	description:"A 'Collection' is an arbitrary group of resources linked with a SpecIF:contains statement. It corresponds to a 'Group' in BPMN Diagrams.",
	propertyTypes:[{id:"PT-Col-Name", title:"dcterms:title", dataType:"DT-ShortString", changedAt:fileDate}], changedAt:fileDate})
	// Folder
	resourceTypes.push({ id:"RT-Fld", title:"SpecIF:Heading",
	description:"Folders with title and text for chapters or descriptive paragraphs.",
	isHeading:true,
	propertyTypes:[{id:"PT-Fld-Name", title:"dcterms:title", dataType:"DT-ShortString", changedAt:fileDate}], changedAt:fileDate})	
	
	var statementTypes = new Array(); // Benötigte Statementtypen werden definiert
	statementTypes.push({ id:"ST-Visibility", title:"SpecIF:shows", 
	description:"Relation: Plan shows Model-Element",
	subjectTypes:["RT-Pln"],
	objectTypes:["RT-Act", "RT-Sta", "RT-Evt"], changedAt:fileDate})
	statementTypes.push({ id:"ST-Containment", title:"SpecIF:contains", 
	description:"Relation: Model-Element contains Model-Element",
	subjectTypes:["RT-Act", "RT-Sta", "RT-Evt"],
	objectTypes:["RT-Act", "RT-Sta", "RT-Evt"], changedAt:fileDate});
	statementTypes.push({ id:"ST-Storage", title:"SpecIF:stores", 
	description:"Relation: Actor (Role, Function) writes and reads State (Information)",
	subjectTypes:["RT-Act"],
	objectTypes:["RT-Sta"], changedAt:fileDate});
	statementTypes.push({ id:"ST-Writing", title:"SpecIF:writes", 
	description:"Relation: Actor (Role, Function) writes State (Information)",
	subjectTypes:["RT-Act"],
	objectTypes:["RT-Sta"], changedAt:fileDate});
	statementTypes.push({ id:"ST-Reading", title:"SpecIF:reads", 
	description:"Relation: Actor (Role, Function) reads State (Information)",
	subjectTypes:["RT-Act"],
	objectTypes:["RT-Sta"], changedAt:fileDate});
	// neue Statements
	statementTypes.push({ id:"ST-Following", title:"SpecIF:follows", 
	description:"A FMC:Actor 'follows' a FMC:Actor; e.g. in a business process or activity flow.",
	subjectTypes:["RT-Act"],
	objectTypes:["RT-Act"], changedAt:fileDate});
	statementTypes.push({ id:"ST-Signalling", title:"SpecIF:signals", 
	description:"A FMC:Actor 'signals' a FMC:Event.",
	subjectTypes:["RT-Act", "RT-Evt"],
	objectTypes:["RT-Evt"], changedAt:fileDate});
	statementTypes.push({ id:"ST-Triggering", title:"SpecIF:triggers", 
	description:"A FMC:Event 'triggers' a FMC:Actor.",
	subjectTypes:["RT-Evt"],
	objectTypes:["RT-Act"], changedAt:fileDate});
	statementTypes.push({ id:"ST-RefferingTo", title:"SpecIF:refersTo", 
	description:"A SpecIF:Comment, SpecIF:Note or SpecIF:Issue 'refers to' any other resource.",
	subjectTypes:["RT-Not"],
	objectTypes:["RT-Pln", "RT-Act", "RT-Sta", "RT-Evt", "RT-Not", "RT-Col"], changedAt:fileDate});
	var hierarchyTypes = new Array(); // Benötigte Hierarchietypen werden definiert
	hierarchyTypes.push({
		id:"HT-BPMN-Prozessmodell",
		title:"SpecIF:Hierarchy",
		description:"Root node of a process model (outline).", 
		changedAt:fileDate
	});
	
	var resources = new Array(); // Resourcen und Statements werden eingebunden
	var statements = new Array();
	

	for (i=0; i < elements.length; i++){
		if (elements[i].hasOwnProperty("resourceType") == true){
			resources.push(elements[i]);
		}
		if (elements[i].hasOwnProperty("statementType") == true){
			statements.push(elements[i]);
		}
	}
	
	var hierarchies = new Array(); // Hierarchiebeziehungen werden eingebunden

	resources = resources.concat([{ // Folder werden angelegt
		id:"Folder1", resourceType:"RT-Fld", title:"Modell-Elemente (Glossar)", properties:[{propertyType:"PT-Fld-Name", value:"Modell-Elemente (Glossar)"}], changedAt:fileDate
	},{
		id:"Folder1.1", resourceType:"RT-Fld", title:"Akteure", properties:[{propertyType:"PT-Fld-Name", value:"Akteure"}], changedAt:fileDate
	},{
		id:"Folder1.2", resourceType:"RT-Fld", title:"Zustände", properties:[{propertyType:"PT-Fld-Name", value:"Zustände"}], changedAt:fileDate
	},{
		id:"Folder1.3", resourceType:"RT-Fld", title:"Ereignisse", properties:[{propertyType:"PT-Fld-Name", value:"Ereignisse"}], changedAt:fileDate
	}]);
	
	nodeList = new Array;
	nodeList.push({id:"N-Diagram", resource:resources[0].id, changedAt:fileDate}) // ID von dem Diagram
	nodeList.push({id:"N-Folder1", resource:"Folder1", nodes:[], changedAt:fileDate});
	nodeList[1].nodes.push({id:"N-Folder1.1", resource:"Folder1.1", nodes:[], changedAt:fileDate});
	nodeList[1].nodes.push({id:"N-Folder1.2", resource:"Folder1.2", nodes:[], changedAt:fileDate});
	nodeList[1].nodes.push({id:"N-Folder1.3", resource:"Folder1.3", nodes:[], changedAt:fileDate});
	
	console.log(nodeList);

	for (i=0; i<resources.length; i++){
		if (resources[i].resourceType == "RT-Act"){
			nodeList[1].nodes[0].nodes.push({id:"N-"+resources[i].id, resource:resources[i].id, changedAt:fileDate})
		}
		if (resources[i].resourceType == "RT-Sta"){
			nodeList[1].nodes[1].nodes.push({id:"N-"+resources[i].id, resource:resources[i].id, changedAt:fileDate})
		}
		if (resources[i].resourceType == "RT-Evt"){
			nodeList[1].nodes[2].nodes.push({id:"N-"+resources[i].id, resource:resources[i].id, changedAt:fileDate})
		}

	}
	
	console.log(nodeList);
	
	hierarchies.push({
		id:"outline",
		title:array.title,
		hierarchyType:"HT-BPMN-Prozessmodell",
		nodes:nodeList, // Für jede Resource, ich kann in die Nodes weitere Nodelists haben
		changedAt:fileDate
	});
	

	
	//Arrays der Wurzel zuordnen
	array.dataTypes = dataTypes;
	array.resourceTypes = resourceTypes; //check
	array.statementTypes = statementTypes; //check
	array.hierarchyTypes = hierarchyTypes; //
	array.resources = resources; //check
	array.statements = statements; //check
	array.hierarchies = hierarchies;
	
	var myJSON = JSON.stringify(array);
	var myBeautyJSON = JSON.stringify(array, null, "\t");
	document.getElementById("output").innerHTML = document.getElementById("output").innerHTML + myBeautyJSON;
	console.log(myJSON);
	zipCreator(myJSON, svgFile);
}

// Herunterladen einer .specifz Datei
function zipCreator(json, svg) {
	var zip = new JSZip();
	zip.file("BPMN.specif", json);
	zip.file("BusinessProcess.svg", svg);
	zip.generateAsync({type:"blob"})
	.then(function (blob) {
		saveAs(blob, "BPMN.specifz");
	});
}

</script>
</head>

<body>

<h2>BPMN 2.0 to SpecIF DEV</h2>

<p>BPMN Grafik
<input type="file" id="SVG">

<p>BPMN XML
<input type="file" id="XML"></p>

<p>Output:</p>
<textarea id="output" name="text" cols="180" rows="20"></textarea>

<p>
<button type="button" onclick="readFile()">BPMN Dateien in .specifz umwandeln</button>
</p>

</body>
</html> 